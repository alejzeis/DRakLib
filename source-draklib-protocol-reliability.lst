       |ï»¿module draklib.protocol.reliability;
       |import draklib.core : RakNetInfo;
       |import draklib.bytestream : ByteStream, OutOfBoundsException;
       |import draklib.protocol.packet;
       |import draklib.util;
       |
       |/// Header for the Container Packet's PID.
       |/// Information taken from 
       |/// https://github.com/OculusVR/RakNet/blob/master/Source/ReliabilityLayer.cpp#L110
       |
       |deprecated("Implementation seems to be incorrect") struct ContainerHeader {
       |        bool isACK;
       |        bool isNACK;
       |        bool isPacketPair;
       |        bool hasBAndAS;
       |        bool isContinuousSend;
       |        bool needsBAndAs;
       |        bool isValid;
       |
       |        ubyte encode() {
0000000|                bool[] bits = new bool[8];
0000000|                bits[0] = isValid; //IsValid
0000000|                if(isACK) {
0000000|                        bits[1] = true;
0000000|                        bits[2] = hasBAndAS;
0000000|                } else if(isNACK) {
0000000|                        bits[1] = false;
0000000|                        bits[2] = true;
       |                } else {
0000000|                        bits[1] = false;
0000000|                        bits[2] = false;
0000000|                        bits[3] = isPacketPair;
0000000|                        bits[4] = isContinuousSend;
0000000|                        bits[5] = needsBAndAs;
       |                }
       |
0000000|                return writeBits(bits);
       |        }
       |
       |        void decode(in ubyte header) {
0000000|                bool[] vals = readBits(header);
0000000|                isValid = vals[0];
0000000|                isACK = vals[1];
0000000|                if(isACK) {
0000000|                        isNACK = false;
0000000|                        isPacketPair = false;
0000000|                        hasBAndAS = vals[2];
       |                } else {
0000000|                        isNACK = vals[2];
0000000|                        if(isNACK) {
0000000|                                isPacketPair = false;
       |                        } else {
0000000|                                isPacketPair = vals[3];
0000000|                                isContinuousSend = vals[4];
0000000|                                needsBAndAs = vals[5];
       |                        }
       |                }
       |        }
       |}
       |
       |enum Reliability {
       |        UNRELIABLE = 0,
       |        UNRELIABLE_SEQUENCED = 1,
       |        RELIABLE = 2,
       |        RELIABLE_ORDERED = 3,
       |        RELIABLE_SEQUENCED = 4,
       |        UNRELIABLE_WITH_ACK_RECEIPT = 5,
       |        RELIABLE_WITH_ACK_RECEIPT = 6,
       |        RELIABLE_ORDERED_WITH_ACK_RECEIPT = 7
       |}
       |
       |class AcknowledgePacket : Packet {
       |        uint[] nums;
       |
       |        override {
       |                protected void _encode(ByteStream stream) {
0000000|                        assert(nums !is null, "no sequence numbers provided");
0000000|                        uint count = cast(uint) nums.length;
0000000|                        uint records = 0;
       |
0000000|                        stream.setPosition(3);
0000000|                        if(count > 0) {
0000000|                                uint pointer = 0;
0000000|                                uint start = nums[0];
0000000|                                uint last = nums[0];
       |
0000000|                                while(pointer + 1 < count) {
0000000|                                        uint current = nums[pointer++];
0000000|                                        uint diff = current - last;
0000000|                                        if(diff == 1) {
0000000|                                                last = current;
0000000|                                        } else if(diff > 1) { // Skip duplicated packets
0000000|                                                if(start == last) {
0000000|                                                        stream.writeByte(0); // False
0000000|                                                        stream.writeUInt24_LE(start);
0000000|                                                        start = last = current;
       |                                                } else {
0000000|                                                        stream.writeByte(1); // True
0000000|                                                        stream.writeUInt24_LE(start);
0000000|                                                        stream.writeUInt24_LE(last);
0000000|                                                        start = last = current;
       |                                                }
0000000|                                                records = records + 1;
       |                                        }
       |                                }
       |
0000000|                                if(start == last) {
0000000|                                        stream.writeByte(1); // True
0000000|                                        stream.writeUInt24_LE(start);
       |                                } else {
0000000|                                        stream.writeByte(0); // False
0000000|                                        stream.writeUInt24_LE(start);
0000000|                                        stream.writeUInt24_LE(last);
       |                                }
0000000|                                records = records + 1;
       |                        }
       |
0000000|                        stream.setPosition(1);
0000000|                        stream.writeUShort(cast(ushort)records);
       |                }
       |
       |                protected void _decode(ByteStream stream) {
0000000|                        uint count = stream.readUShort();
0000000|                        uint pkCount = 0;
0000000|                        uint cnt = 0;
0000000|                        for(uint i = 0; i < count && stream.getRemainingLength() > 0 && cnt < 4096; i++) {
0000000|                                if(stream.readByte == 0) {
0000000|                                        uint start = stream.readUInt24_LE();
0000000|                                        uint end = stream.readUInt24_LE();
0000000|                                        if((end - start) > 512) {
0000000|                                                end = start + 512;
       |                                        }
0000000|                                        for(uint c = start; c <= end; c++) {
0000000|                                                cnt = cnt + 1;
0000000|                                                nums[pkCount++] = c;
       |                                        }
       |                                } else {
0000000|                                        nums[pkCount++] = stream.readUInt24_LE();
       |                                }
       |                        }
       |                }
       |
       |                uint getSize() {
0000000|                        return 2048;
       |                }
       |        }
       |}
       |
       |class ACKPacket : AcknowledgePacket {
       |        override {
       |                ubyte getID() {
0000000|                        return RakNetInfo.ACK;
       |                }
       |        }
       |}
       |
       |class NACKPacket : AcknowledgePacket {
       |        override {
       |                ubyte getID() {
0000000|                        return RakNetInfo.NACK;
       |                }
       |        }
       |}
       |
       |class ContainerPacket : Packet {
       |        //ContainerHeader header;
       |        ubyte header;
       |        uint sequenceNumber;
       |        EncapsulatedPacket[] packets;
       |
       |        override {
       |                void decode(byte[] data) {
0000000|                        ByteStream stream = ByteStream.wrap(data);
       |                        /*
       |                        header = ContainerHeader();
       |                        header.decode(stream.readUByte());
       |                        */
0000000|                        header = stream.readUByte();
0000000|                        _decode(stream);
       |                }
       |
       |                protected void _encode(ByteStream stream) {
0000000|                        stream.writeUInt24_LE(sequenceNumber);
0000000|                        foreach(packet; packets) {
0000000|                                packet._encode(stream);
       |                        }
       |                }
       |                
       |                protected void _decode(ByteStream stream) {
0000000|                        packets = cast(EncapsulatedPacket[]) [];
       |
0000000|                        sequenceNumber = stream.readUInt24_LE();
0000000|                        while(stream.getRemainingLength() > 0) {
       |                                try {
0000000|                                        EncapsulatedPacket ep = new EncapsulatedPacket();
0000000|                                        ep._decode(stream);
0000000|                                        packets ~= ep;
       |                                } catch(OutOfBoundsException e) {
       |                                        debug {
       |                                                import std.stdio;
       |                                                writeln("WARNING: OutofBoundsException while processing ContainerPacket!");
       |                                        }
       |                                }
       |                        }
       |                }
       |                
       |                ubyte getID() {
0000000|                        return header;
       |                }
       |                
       |                uint getSize() {
0000000|                        uint size = 4;
0000000|                        foreach(pk; packets) {
0000000|                                size += pk.getSize();
       |                        }
0000000|                        return size;
       |                }
       |        }
       |}
       |
       |class EncapsulatedPacket : Packet {
       |        byte reliability;
       |        bool split = false;
       |        int messageIndex = -1;
       |        int orderIndex = -1;
       |        byte orderChannel = -1;
       |        uint splitCount;
       |        ushort splitID;
       |        uint splitIndex;
       |        byte[] payload;
       |
       |        override {
       |                protected void _encode(ByteStream stream) {
0000000|                        stream.writeByte(cast(byte) ((reliability << 5) | (split ? 0b00010000 : 0)));
0000000|                        stream.writeUShort(cast(ushort) (payload.length * 8));
0000000|                        if(reliability >= Reliability.RELIABLE && reliability != Reliability.UNRELIABLE_WITH_ACK_RECEIPT) {
0000000|                                stream.writeUInt24_LE(messageIndex);
       |                        }
0000000|                        if(reliability <= Reliability.RELIABLE_SEQUENCED && reliability != Reliability.RELIABLE_ORDERED) {
0000000|                                stream.writeUInt24_LE(orderIndex);
0000000|                                stream.writeByte(orderChannel);
       |                        }
0000000|                        if(split) {
0000000|                                stream.writeUInt(splitCount);
0000000|                                stream.writeUShort(splitID);
0000000|                                stream.writeUInt(splitIndex);
       |                        }
0000000|                        stream.write(payload);
       |                }
       |                
       |                protected void _decode(ByteStream stream) {
0000000|                        ubyte header = stream.readUByte();
0000000|                        reliability = (header & 0b11100000) >> 5;
0000000|                        split = (header & 0b00010000) > 0;
       |                        //writeln(reliability, " ", split);
       |
       |                        import std.math : ceil;
       |
0000000|                        ushort len = cast(ushort) ceil(cast(float) stream.readUShort() / 8);
0000000|                        if(reliability > 0) {
0000000|                                if(reliability >= Reliability.RELIABLE && Reliability.UNRELIABLE_WITH_ACK_RECEIPT) {
0000000|                                        messageIndex = stream.readUInt24_LE();
       |                                }
0000000|                                if(reliability <= Reliability.RELIABLE_SEQUENCED && reliability != Reliability.RELIABLE) {
0000000|                                        orderIndex = stream.readUInt24_LE();
0000000|                                        orderChannel = stream.readByte();
       |                                }
       |                        }
0000000|                        if(split) {
0000000|                                splitCount = stream.readUInt();
0000000|                                splitID = stream.readUShort();
0000000|                                splitIndex = stream.readUInt();
       |                        }
0000000|                        payload = stream.read(len);
       |                }
       |                
       |                ubyte getID() {
0000000|                        return 0;
       |                }
       |                
       |                uint getSize() {
0000000|                        return cast(uint) (3 + (messageIndex != -1 ? 3 : 0) + (orderIndex != -1 && orderChannel != -1 ? 4 :0) + (split ? 10 : 0) + payload.length);
       |                }
       |        }
       |}
source/draklib/protocol/reliability.d is 0% covered
